#
# https://github.com/dircmd/dircmd
#
DIRCMD_SHM="/dev/shm/dircmd-${USER}-$$"
if [[ -d ${DIRCMD_SHM} ]]; then
  rm -rf ${DIRCMD_SHM}
fi
mkdir -p ${DIRCMD_SHM}
chmod go=-rwx ${DIRCMD_SHM}
trap "$(trap -p 'EXIT' | cut -d "'" -f 2- \
  | awk -F "'" '{ if (NF >= 2) printf("%s; ",$(NF-1)); }')rm -rf ${DIRCMD_SHM}" EXIT
_dircmd_restore_stdin()
{
  exec 0<&6 6<&-
}
_dircmd_hook()
{
  local previous_exit_status=$?
  local DIRCMD_LAST DIRCMD_CURRENT
  DIRCMD_LAST="${OLDPWD}"
  DIRCMD_CURRENT="${PWD}"
  exec 6<&0
  _dircmd_run_exit()
  {
    cd "${1}"
    if [[ -d "${DIRCMD_SHM}${PWD}" ]]; then
      if [[ -d .dircmd ]]; then
        for ES in $(ls .dircmd/*exit 2>/dev/null) ; do
          echo "Source Exit: ${ES}"
          source "${ES}" < /dev/null
        done
      fi
      rmdir "${DIRCMD_SHM}${PWD}"
    fi
  }
  _dircmd_run_entry()
  {
    cd ${1}
    if [[ ! -d "${DIRCMD_SHM}${PWD}" ]]; then
      if [[ -d .dircmd ]]; then
        for ES in $(ls .dircmd/*entry 2>/dev/null) ; do
          echo "Source Entry: ${ES}"
          source "${ES}" < /dev/null
        done
      fi
      mkdir -p "${DIRCMD_SHM}${PWD}"
    fi
  }
  if [[ -d "${DIRCMD_LAST}" ]]; then
    local DIRCMD_LIST

    if echo "${DIRCMD_LAST}" | egrep -q "^${DIRCMD_CURRENT}$" ;then
      #echo "# Staying in same directory."
      _dircmd_run_entry "${PWD}"
   else
      if echo "${DIRCMD_CURRENT}" | egrep -q "^${DIRCMD_LAST}" ;then
        #echo "# Going into a sub directory."
        while ! echo "${PWD}" | egrep -q "^${DIRCMD_LAST}$" ; do
          if [[ -d .dircmd ]]; then
            DIRCMD_LIST[${#DIRCMD_LIST[@]}]="${PWD}"
          fi
          cd ..
        done
        for (( i=0 ; i < ${#DIRCMD_LIST[@]}; i++ )); do
          _dircmd_run_entry "${DIRCMD_LIST[${i}]}"
        done
      else
        if echo "${DIRCMD_LAST}" | egrep -q "^${DIRCMD_CURRENT}" ;then
          #echo "# Going up to a parent directory."
          cd "${DIRCMD_LAST}"
          while echo "${PWD}" | egrep -q "^${DIRCMD_CURRENT}" ; do
            if [[ -d .dircmd ]]; then
              DIRCMD_LIST[${#DIRCMD_LIST[@]}]="${PWD}"
            fi
            cd ..
          done
          for (( i=0 ; i < ${#DIRCMD_LIST[@]}; i++ )); do
            _dircmd_run_exit "${DIRCMD_LIST[${i}]}"
          done
        else
          #echo "# Going out the tree."
          cd "${DIRCMD_LAST}"
          while ! echo "${PWD}" | egrep -q "^/$" ; do
            if [[ -d .dircmd ]]; then
              DIRCMD_LIST[${#DIRCMD_LIST[@]}]="${PWD}"
            fi
            cd ..
          done
          for (( i=0 ; i < ${#DIRCMD_LIST[@]}; i++ )); do
            _dircmd_run_exit "${DIRCMD_LIST[${i}]}"
          done
          unset DIRCMD_LIST
          local DIRCMD_LIST
          cd "${DIRCMD_CURRENT}"
          while ! echo "${PWD}" | egrep -q "^/$" ; do
            if [[ -d .dircmd ]]; then
              DIRCMD_LIST[${#DIRCMD_LIST[@]}]="${PWD}"
            fi
            cd ..
          done
          if [[ -d .dircmd ]]; then
            DIRCMD_LIST[${#DIRCMD_LIST[@]}]="${PWD}"
          fi
          for (( i=0 ; i < ${#DIRCMD_LIST[@]}; i++ )); do
            _dircmd_run_entry "${DIRCMD_LIST[${i}]}"
          done
        fi
      fi
    fi
  fi
  cd "${DIRCMD_CURRENT}"
  _dircmd_restore_stdin
  return $previous_exit_status
}
if ! [[ "${PROMPT_COMMAND}" =~ _dircmd_hook ]]; then
  PROMPT_COMMAND="type -t _dircmd_hook >/dev/null && _dircmd_hook;${PROMPT_COMMAND}"
  cd ~
fi
